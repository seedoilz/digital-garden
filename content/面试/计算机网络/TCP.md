---
aliases: 
title: TCP
date created: 2024-08-17 13:08:00
date modified: 2024-08-27 11:08:59
---
## 概念
TCP 协议，**传输控制协议**（英语：Transmission Control Protocol，缩写为：TCP）是一种**面向连接的、可靠的、基于字节流的**通信协议。

### 三次握手
**三次握手其实就是建立连接的过程**。其过程如图：
![image.png](https://typora-tes.oss-cn-shanghai.aliyuncs.com/picgo/20240817145254.png)

#### 为什么需要握手？
TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。 为了实现这个需求， 很自然地就会引出序号（sequence number） 和 确认号（acknowledgement number） 的使用。

发送方在发送数据包（假设大小为 10 byte）时， 同时送上一个序号( 假设为 500)，那么接收方收到这个数据包以后， 就可以回复一个确认号（510 = 500 + 10） 告诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包， 序号从 510 开始” 。

> [!NOTE] 为什么需要三次握手？
> 正如上文所描述的，为了实现可靠传输，发送方和接收方始终需要同步( SYNchronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始 。 由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。

### 四次挥手
![image.png](https://typora-tes.oss-cn-shanghai.aliyuncs.com/picgo/20240817152028.png)
1）第一次挥手：客户端向服务器发起请求释放连接的 TCP 报文，置 FIN 为 1。**客户端进入终止等待 - 1 阶段**。  
2）第二次挥手：服务器端接收到从客户端发出的 TCP 报文之后，确认了客户端想要释放连接，**服务器端进入 CLOSE-WAIT 阶段**，并向客户端发送一段 TCP 报文。**客户端收到后进入种植等待 - 2 阶段**。
3）第三次挥手：服务器做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段 TCP 报文。。此时服务器**进入最后确认阶段**。  
4）第四次挥手：客户端收到从服务器端发出的 TCP 报文，确认了服务器端已做好释放连接的准备，于是**进入时间等待阶段**，并向服务器端发送一段报文。**注意：第四次挥手后客户端不会立即进入 closed 阶段，而是等待 2MSL 再关闭。**

> [!NOTE] 为什么需要四次挥手？
> 为什么关闭一个连接需要四次挥手呢？其实这是为了确保数据能够完整地传输。TCP是面向连接的协议，它需要保证数据的可靠传输。如果只用三次挥手，可能会导致有数据丢失或未完全传输完毕的情况。因此，四次挥手的设计是为了保证双方的数据能够在各自完全关闭连接之前顺利完成传输。
> 
> CLOSE-WAIT状态详解
> 在CLOSE-WAIT状态下，服务端已经收到了客户端发来的FIN包，并回了一个ACK包。这意味着客户端已经关闭了它的一半连接，但服务端还没有关闭它的那一半。CLOSE-WAIT状态的存在是为了给服务端一些时间处理未完成的任务，然后再发送FIN包给客户端，最终完成连接的关闭。
> 
> TIME-WAIT状态详解
> TIME-WAIT状态是为了确保所有的数据包都能被可靠地接收，并处理网络中的延迟或丢包问题。客户端在发送最后一个ACK包后，会进入TIME-WAIT状态，等待一段时间（通常是两倍的报文最大生存时间，2MSL），以确保服务端收到了ACK包，并且不会出现新旧连接的数据混淆问题。

> [!NOTE] 为什么上图中的A在TIME-WAIT状态必须等待2MSL时间呢？
> 第一，为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。   
> 
> 第二，A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。

### 超时重传机制
TCP的超时重传机制是指在TCP协议中，发送方发送数据后会启动一个定时器，如果在规定的时间内没有收到接收方的确认应答，就会触发超时重传，重新发送数据包。超时重传的目的是为了保证数据的可靠传输，因为在网络通信中，数据包可能会丢失或者延迟到达，如果发送方没有收到接收方的确认应答，就无法确定数据包是否已经成功到达，因此需要通过超时重传机制来保证数据的可靠性。

#### 快速重传
>`超时重传`最大的问题就是太慢了，需要一直等到超时了才重传，  
「快速重传」可以解决超时重发的时间等待问题。

**快速重传机制是如何工作的？**  
快重传要求，接收者如果接收到一个`乱序的分组`的话，就返回对前一个正确分组的确认应答，  
当发送方连续收到`三个冗余ACK`，就会马上`快速重传丢失数据`，不必等到超时时间再重传。
![image.png](https://typora-tes.oss-cn-shanghai.aliyuncs.com/picgo/20240817164600.png)

### SACK机制
>selective acknowledgment，添加sack功能需要在TCP包开头加两个选项，一个是开启选项（enabling option），另一个是sack选项（sack option）本身

在早期的TCP拥塞控制中都是通过收到duplicate ack（默认3个）来trigger[[#快速重传]]，这样会导致每一次重传的时候只能重传一个包，容易造成timeout。

而如果开启SACK，每一个sack段记录的是已经收到的连续的包，sack段与sack段之间断片的，也就是还没收到的。

要注意的是开启sack选项，也是有**弊端**的，因为丢包意味着网络很可能已经拥塞，这时如果一次重传多个包，很可能会造成网络更加拥塞。

#### D-SACK机制
##### 好处
1. 让发送方知道，是发送的包丢了，还是返回的 ACK 包丢了；
2. 网络上是否出现了包失序；
3. 数据包是否被网络上的路由器复制并转发了
4. 是不是自己的 timeout 太小了，导致重传

